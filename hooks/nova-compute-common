#!/bin/bash -e

CHARM="nova-compute"
PACKAGES="nova-compute python-keystone genisoimage uuid charm-helper-sh"
SERVICES="nova-compute"
CONF_DIR="/etc/nova"
NOVA_CONF=$(config-get nova-config)
API_CONF="/etc/nova/api-paste.ini"
QUANTUM_CONF="/etc/quantum/quantum.conf"
LIBVIRTD_CONF="/etc/libvirt/libvirtd.conf"

if [ -f /etc/nova/nm.conf ]; then
    NET_MANAGER=$(cat /etc/nova/nm.conf)
fi
case $NET_MANAGER in
  "Quantum")
    QUANTUM_PLUGIN=$(cat /etc/nova/quantum_plugin.conf)
    case $QUANTUM_PLUGIN in
      "ovs")
        SERVICES="$SERVICES quantum-plugin-openvswitch-agent"
        QUANTUM_PLUGIN_CONF="/etc/quantum/plugins/openvswitch/ovs_quantum_plugin.ini"
        ;;
      "nvp")
        QUANTUM_PLUGIN_CONF="/etc/quantum/plugins/nicira/nvp.ini"
        ;;
       *)
        juju-log "Unrecognised plugin for quantum: $QUANTUM_PLUGIN" && exit 1
        ;;
    esac
    ;;
  "FlatManager"|"FlatDHCPManager")
    SERVICES="$SERVICES nova-api nova-network"
    ;;
esac

if [[ -e $CHARM_DIR/lib/nova/nova-common ]] ; then
  . $CHARM_DIR/lib/nova/nova-common
else
  juju-log "$CHARM: Couldn't load $CHARM_DIR/lib/nova-common" && exit 1
fi

determine_compute_package() {
  # determines the appropriate nova-compute package to install
  # for the configured virt-type.
  local virt_type="$1"
  local compute_pkg=""
  case $virt_type in
    "kvm") compute_pkg="nova-compute-kvm";;
    "qemu") compute_pkg="nova-compute-qemu";;
    "xen") compute_pkg="nova-compute-xen";;
    "uml") compute_pkg="nova-compute-uml";;
    "lxc") compute_pkg="nova-compute-lxc";;
    *) error_out "ERROR: Unsupported virt_type=$virt_type";;
  esac
  echo "$compute_pkg"
}

function setup_bridge {
  # XXX This is required by nova-network and will likely move somewhere else
  # once we can split these services up into seperate formulas.
  br=$1
  ip=$2
  netmask=$3
  [[ -z $br ]] && br="br100"
  [[ -z $ip ]] && ip="11.0.0.1"
  [[ -z $netmask ]] && netmask="255.255.255.0"

  apt-get -y install bridge-utils augeas-lenses augeas-tools
  echo "Configuring bridge $br ($ip $netmask)"
  context="/files/etc/network/interfaces"
  augtool <<EOF
  set $context/auto[child::1 = "$br"]/1 $br
  set $context/iface[. = '$br'] $br
  set $context/iface[. = '$br']/family inet
  set $context/iface[. = '$br']/method static
  set $context/iface[. = '$br']/address $ip
  set $context/iface[. = '$br']/netmask $netmask
  set $context/iface[. = '$br']/bridge_ports none 
  save
EOF
  ifdown -a ; ifup -a
}

function configure_network_manager {
  # needed by the nova-network bits
  # to be expanded later to cover flatDhcp and VLAN
  echo "$0: configuring $1 network manager"
  local net_manager=$1
  local quantum_plugin=$2
  local network_bridge=$(config-get bridge-interface)
  local private_address=$(get_ip `unit-get private-address`)
  # Check to ensure we can actually resolve
  # the local unit IP address
  [[ -n $private_address ]] || {
    juju-log "Unable to resolve local IP address"
    exit 1
  }

  # Store the network manager and quantum plugin
  # for use in later hook invocations
  [[ -n $net_manager ]] && echo $net_manager > /etc/nova/nm.conf
  [[ -n $quantum_plugin ]] && echo $quantum_plugin > /etc/nova/quantum_plugin.conf

  case $net_manager in
    "FlatManager"|"FlatDHCPManager")
      apt-get -y install nova-api nova-network
      SERVICES="$SERVICES nova-api nova-network"
      ;;&
    "FlatManager")
      local bridge_ip=$(config-get bridge-ip)
      local bridge_netmask=$(config-get bridge-netmask)
      setup_bridge $network_bridge $bridge_ip $bridge_netmask
      set_or_update network_manager nova.network.manager.FlatManager
      set_or_update flat_network_bridge $network_bridge
      ;;
    "FlatDHCPManager")
      local flat_interface=$(config-get flat-interface)
      local ec2_host=$(relation-get ec2_host)
      [[ -z $ec2_host ]] && juju-log "nova-compute: Missing ec2_host" \
        && exit 0
      set_or_update network_manager nova.network.manager.FlatDHCPManager
      # the interface on which bridge is built
      set_or_update flat_interface $flat_interface
      # address of API server to forward requests
      set_or_update ec2_dmz_host $ec2_host
      ;;
    "Quantum")
      local keystone_host=$(relation-get keystone_host)
      [[ -z $keystone_host ]] && juju-log "nova-compute: Missing keystone host" \
        && exit 0
      set_or_update "network_api_class" "nova.network.quantumv2.api.API"
      set_or_update "quantum_auth_strategy" "keystone"
      set_or_update "quantum_url" "http://$(relation-get quantum_host):9696"
      set_or_update "quantum_admin_tenant_name" "$(relation-get service_tenant)"
      set_or_update "quantum_admin_username" "$(relation-get service_username)"
      set_or_update "quantum_admin_password" "$(relation-get service_password)"
      set_or_update "quantum_admin_auth_url" \
                    "http://$(relation-get keystone_host):$(relation-get auth_port)/v2.0"
      set_or_update "force_config_drive" "True"
      case $quantum_plugin in
        "ovs")
          apt-get -y install openvswitch-datapath-dkms
          apt-get -y install quantum-plugin-openvswitch-agent
          local quantum_plugin_conf="/etc/quantum/plugins/openvswitch/ovs_quantum_plugin.ini"
          set_or_update "core_plugin" "quantum.plugins.openvswitch.ovs_quantum_plugin.OVSQuantumPluginV2" "$QUANTUM_CONF"
          set_or_update "libvirt_vif_driver" "nova.virt.libvirt.vif.LibvirtHybridOVSBridgeDriver"
          set_or_update "libvirt_use_virtio_for_bridges" "True"
          set_or_update "tenant_network_type" "gre" $quantum_plugin_conf "OVS"
          set_or_update "enable_tunneling" "True" $quantum_plugin_conf "OVS"
          set_or_update "tunnel_id_ranges" "1:1000" $quantum_plugin_conf "OVS"
          set_or_update "local_ip" "$private_address" $quantum_plugin_conf "OVS"
          SERVICES="$SERVICES quantum-plugin-openvswitch-agent"
          ;;
      esac
      set_or_update "bind_host" "0.0.0.0" "$QUANTUM_CONF"
      ;;
    *) echo "ERROR: Invalid network manager $1" && exit 1 ;;
  esac
}

BR_INT="br-int"

function configure_quantum_bridge {
  if ! ovs-vsctl show | grep -q "Bridge $BR_INT"; then
    ovs-vsctl add-br $BR_INT
  fi
}

function initialize_ssh_keys {
  # generate ssh keypair for root if one does not exist or
  # the pari is not complete.
  local pub="/root/.ssh/id_rsa"
  local priv="/root/.ssh/id_rsa.pub"
  if [[ -e $pub ]] &&
     [[ -e $priv ]] ; then
    juju-log "$CHARM: SSH credentials already exist for root."
    return 0
  fi
  juju-log "$CHARM: Initializing new SSH key pair for live migration."
  [[ -e $pub ]] && mv $pub $pub.$(date +"%s")
  [[ -e $priv ]] && mv $priv $priv.$(date +"%s")
  local keyname=$(echo $JUJU_UNIT_NAME | sed -e 's,/,-,g')
  echo -e "\n" | ssh-keygen -C "$keyname" -N ""
}

function ssh_authorized_keys {
  local key="$1"
  local action="$2"
  local exists=""
  local authorized_keys="/root/.ssh/authorized_keys"

  [[ -e "$authorized_keys" ]] &&
    grep -q "^$key" $authorized_keys && exists="true"

  if [[ "$action" == "add" ]] ; then
    [[ -n "$exists" ]] &&
      juju-log "$CHARM: SSH key already authorized for $JUJU_REMOTE_UNIT." &&
        return 0

    echo "$key" >>$authorized_keys
    juju-log "$CHARM: Authorized new SSH key for $JUJU_REMOTE_UNIT."
    return 0
  elif [[ "$action" == "remove" ]] ; then
    # we have no way of getting to the relation state during a departed hook.
    # we only have the peer's unit name, so remove an authorized key based on
    # its comment, which should can be derived from the remote unit name and
    # gets passed in here from caller as key/$1
    local key_ln=$(sed -n "\, ${key}$,=" $authorized_keys)
    [[ -z "$key_ln" ]] &&
      juju-log "$CHARM: Cannot remove SSH key for $key, not authorized?" &&
        return 0

    for ln in $key_ln ; do
      sed -i "${ln}d" $authorized_keys
      juju-log "$CHARM: Removed existing SSH key ($key) from authorized_keys."
    done
    return 0
  else
    error_out "$CHARM: ssh_authorize_keys() invalid action specified: $action."
  fi
}

function ssh_known_hosts {
  # Keeps the system-wide SSH known hosts file up to date with compute
  # nodes host keys.
  local host="$1"
  local known_hosts="/etc/ssh/ssh_known_hosts"
  juju-log "$CHARM: Ensuring host is included and up to date in $known_hosts."

  [[ ! -e $known_hosts ]] && touch $known_hosts

  local remote_key=""
  remote_key=$(ssh-keyscan -H -t rsa $host) ||
    error_out "$CHARM: Couldn't obtain SSH host key from $host."
  local existing=$(ssh-keygen -f $known_hosts -H -F $host | tail -n1)
  if [[ -n "$existing" ]] ; then
    juju-log "$CHARM: Found existing SSH known host key for $host."
    [[ "$existing" == "$remote_key" ]] && echo "HI"
    remote=$(echo $remote_key | awk '{ print $2" "$3 }')
    existing=$(echo $existing | awk '{ print $2" "$3 }')
    if [[ "$remote" == "$existing" ]] ; then
      juju-log "$CHARM: SSH known host key for $host is up to date."
      return 0
    fi
    juju-log "$CHARM: Removing outdated SSH host key for $host."
    ssh-keygen -f $known_hosts -R $host
  else
    juju-log "$CHARM: No known hosts entry for $host."
  fi
  juju-log "$CHARM: Adding new SSH known hosts entry for $host."
  echo $remote_key >>$known_hosts
}

function libvirt_tcp_listening {
  # toggle libvirtd's tcp listening in both /etc/default/libvirt-bin
  # and /etc/libvirt/libvirtd.conf.
  local toggle="$1"
  juju-log "$CHARM: Configuring libvirt tcp listening: $toggle."
  local cur_opts=$(grep "^libvirtd_opts" /etc/default/libvirt-bin |
                   cut -d= -f2 |  sed -e 's/\"//g')
  local new_opts=""

  if [[ "$toggle" == "on" ]] ; then
    if [[ -z "$cur_opts" ]] ; then
      echo "libvirtd_opts=\"-d -l\"" >>/etc/default/libvirt-bin
    elif ! echo "$cur_opts" | grep -q "\-l" ; then
      new_opts="$cur_opts -l"
      sed -i "s|\(libvirtd_opts=\).*|\1\"$new_opts\"|" /etc/default/libvirt-bin
    fi
    set_or_update "listen_tcp" 1 $LIBVIRTD_CONF
  elif [[ "$toggle" == "off" ]] ; then
    if echo "$cur_opts" | grep -q "\-l" ; then
      new_opts=$(echo $cur_opts | sed -e 's/\-l//g')
    fi
    set_or_update "listen_tcp" 0  $LIBVIRTD_CONF
  fi

  [[ -n "$new_opts" ]] &&
    sed -i "s|\(libvirtd_opts=\).*|\1\"$new_opts\"|" /etc/default/libvirt-bin

  return 0
}


function configure_migration {
  local enable_migration=$(config-get enable-live-migration)

  if [[ "$enable_migration" != "True" ]] &&
     [[ "$enable_migraiton" != "true" ]] ; then
     libvirt_tcp_listening "off"
     return $?
  fi

  libvirt_tcp_listening "on"

  case "$(config-get migration-auth-type)" in
    "none"|"None")
      set_or_update "listen_tls" 0 $LIBVIRTD_CONF
      set_or_update "auth_tcp" "\"none\"" $LIBVIRTD_CONF
      ;;
    "ssh")
      set_or_update "listen_tls" 0 $LIBVIRTD_CONF
      set_or_update "live_migration_uri" "qemu+ssh://%s/system" $NOVA_CONF
      initialize_ssh_keys
      service_ctl nova-compute restart ;;
    "sasl") return 0 ;;
  esac

  # Trigger on peer relations to allow all peers negotiate authentication
  # among themselves  (if we are not the only peer).
  relids="$(relation-ids compute-peer)"
  [[ "$(echo "$relids" | wc -l)" == 1 ]] && return 0
  for id in $relids ; do
    compute_peer "joined" "$id"
  done
}

function configure_libvirt {
  cat > /etc/libvirt/qemu.conf << EOF
# File installed by Juju nova-compute charm
cgroup_device_acl = [
   "/dev/null", "/dev/full", "/dev/zero",
   "/dev/random", "/dev/urandom",
   "/dev/ptmx", "/dev/kvm", "/dev/kqemu",
   "/dev/rtc", "/dev/hpet", "/dev/net/tun",
]
EOF
  configure_migration
  service libvirt-bin restart
}
